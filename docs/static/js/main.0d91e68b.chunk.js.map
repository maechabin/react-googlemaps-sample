{"version":3,"sources":["App.tsx","registerServiceWorker.ts","index.tsx"],"names":["App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","gmapsRef","React","initMap","google","mapOptions","center","maps","LatLng","zoom","mapTypeId","MapTypeId","ROADMAP","bounds","LatLngBounds","map","Map","current","title","position","lat","lng","forEach","point","marker","Marker","draggable","opacity","setPosition","extend","getPosition","infoWindow","InfoWindow","content","addListener","open","fitBounds","lineSymbol","path","SymbolPath","CIRCLE","scale","strokeColor","line","Polyline","icons","icon","offset","animateCircle","count","window","setInterval","get","set","Fragment","react","ref","style","width","height","bottom","zIndex","textAlign","fontWeight","fontSize","href","target","rel","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","catch","error","ReactDOM","src_App_0","document","getElementById","URL","process","toString","origin","addEventListener","concat","fetch","response","status","headers","indexOf","ready","unregister","reload","checkValidServiceWorker","registerServiceWorker"],"mappings":"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","file":"static/js/main.0d91e68b.chunk.js","sourcesContent":["import * as React from 'react';\nimport './App.css';\n\n/** 取得するProps */\ninterface AppProps {\n  google: any;\n}\n\n/** マーカーの情報 */\ninterface Point {\n  title: string;\n  position: {\n    lat: number;\n    lng: number;\n  };\n}\n\nclass App extends React.Component<AppProps, any> {\n  gmapsRef = React.createRef<HTMLDivElement>();\n\n  constructor(props: AppProps) {\n    super(props);\n  }\n\n  componentDidMount(): void {\n    this.initMap();\n  }\n\n  initMap(): void {\n    const { google } = this.props;\n    /**\n     * 地図を表示する際のオプション（初期表示）\n     * Mapsのオプション一覧\n     * https://developers.google.com/maps/documentation/javascript/reference/map#MapOptions\n     */\n    const mapOptions: google.maps.MapOptions = {\n      center: new google.maps.LatLng(-34.397, 150.644),\n      zoom: 8,\n      mapTypeId: google.maps.MapTypeId.ROADMAP,\n    };\n\n    /** 範囲（境界）のインスタンスを作成するクラス */\n    const bounds: google.maps.LatLngBounds = new google.maps.LatLngBounds();\n\n    /** Mapオブジェクトに地図表示要素情報とオプション情報を渡し、インスタンス生成 */\n    const map: google.maps.Map = new google.maps.Map(this.gmapsRef.current, mapOptions); // <= refで取得した要素\n\n    /** Markerを表示する拠点リスト */\n    const points: Point[] = [\n      { title: 'maker1', position: { lat: -25.363, lng: 131.044 } },\n      { title: 'maker2', position: { lat: -34.397, lng: 11.044 } },\n      { title: 'maker3', position: { lat: 34.397, lng: 25.044 } },\n      { title: 'maker4', position: { lat: 24.397, lng: 90.044 } },\n    ];\n\n    /** Markerを表示 */\n    points.forEach((point: Point) => {\n      /**\n       * Markerを設定\n       * \bMarkerオプション\n       * https://developers.google.com/maps/documentation/javascript/reference/marker#MarkerOptions\n       */\n      const marker: google.maps.Marker = new google.maps.Marker({\n        map,\n        draggable: true, // ドラッグできるか\n        opacity: 0.7, // 透明度\n        title: point.title,\n      });\n\n      /** マーカーに位置情報をセット */\n      marker.setPosition(point.position);\n\n      /** 位置情報を範囲に追加 */\n      bounds.extend(marker.getPosition());\n\n      /** 吹き出しを設定 */\n      const infoWindow: google.maps.InfoWindow = new google.maps.InfoWindow({\n        content: point.title,\n      });\n\n      /** クリック時の処理設定（吹き出し表示） */\n      marker.addListener(\n        'click',\n        (): void => {\n          infoWindow.open(map, marker);\n        },\n      );\n    });\n\n    /** すべてのMarkerを地図に収める */\n    map.fitBounds(bounds);\n\n    /**\n     * polyline上を動くシンボル\n     * https://developers.google.com/maps/documentation/javascript/symbols#animate\n     * */\n    const lineSymbol = {\n      path: google.maps.SymbolPath.CIRCLE,\n      scale: 8,\n      strokeColor: '#113345',\n    };\n\n    /** polylineを表示 */\n    const line: google.maps.Polyline = new google.maps.Polyline({\n      path: [\n        { lat: 34.397, lng: 25.044 },\n        { lat: -34.397, lng: 11.044 },\n        { lat: -25.363, lng: 131.044 },\n        { lat: 24.397, lng: 90.044 },\n        { lat: 34.397, lng: 25.044 },\n      ],\n      icons: [\n        {\n          icon: lineSymbol,\n          offset: '100%',\n        },\n      ],\n      strokeColor: '#ccc',\n      map: map,\n    });\n\n    /** アニメーションを実行 */\n    this.animateCircle(line);\n  }\n\n  /**\n   * シンボルをpolylineに沿ってアニメーションさせる\n   * */\n  private animateCircle(line: google.maps.Polyline) {\n    let count = 0;\n    window.setInterval(() => {\n      count = (count + 1) % 200;\n\n      const icons = line.get('icons');\n      icons[0].offset = count / 2 + '%';\n      line.set('icons', icons);\n    }, 40);\n  }\n\n  render(): JSX.Element {\n    const Fragment = React.Fragment;\n    const style1 = { width: '100vw', height: '100vh' } as React.CSSProperties;\n    const style2 = {\n      position: 'absolute',\n      bottom: '32px',\n      zIndex: 100,\n      width: '100%',\n      textAlign: 'center',\n      fontWeight: 'bold',\n      fontSize: '24px',\n    } as React.CSSProperties;\n\n    return (\n      <Fragment>\n        <div ref={this.gmapsRef} style={style1}>\n          Google Maps\n        </div>\n        <div style={style2}>\n          <a\n            href=\"https://github.com/maechabin/react-googlemaps-sample\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\">\n            maechabin/react-googlemaps-sample - GitHub\n          </a>\n        </div>\n      </Fragment>\n    );\n  }\n}\n\nexport default App;\n","// tslint:disable:no-console\n// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the 'N+1' visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL!, window.location.toString());\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://goo.gl/SC7cgQ',\n          );\n        });\n      } else {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker) {\n          installingWorker.onstatechange = () => {\n            if (installingWorker.state === 'installed') {\n              if (navigator.serviceWorker.controller) {\n                // At this point, the old content will have been purged and\n                // the fresh content will have been added to the cache.\n                // It's the perfect time to display a 'New content is\n                // available; please refresh.' message in your web app.\n                console.log('New content is available; please refresh.');\n              } else {\n                // At this point, everything has been precached.\n                // It's the perfect time to display a\n                // 'Content is cached for offline use.' message.\n                console.log('Content is cached for offline use.');\n              }\n            }\n          };\n        }\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type')!.indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\n\ndeclare const google: any;\n\nReactDOM.render(<App google={google} />, document.getElementById('root'));\nregisterServiceWorker();\n"],"sourceRoot":""}